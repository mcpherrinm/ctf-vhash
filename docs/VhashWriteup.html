<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ol{margin:0;padding:0}table td,table th{padding:0}.c1{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:8pt;font-family:"Courier New";font-style:normal}.c6{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:26pt;font-family:"Arial";font-style:normal}.c3{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c0{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c7{padding-top:0pt;padding-bottom:3pt;line-height:1.15;page-break-after:avoid;text-align:left}.c5{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c4{font-style:italic}.c2{height:11pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c5"><p class="c7 title" id="h.mvtzvtqcym2n"><span class="c6">BSIDES CTF vhash-fixed</span></p><p class="c0 c2"><span class="c3"></span></p><p class="c0"><span class="c4">Disclaimer: &nbsp;I didn&rsquo;t actually fully solve this problem, there&rsquo;s some bug in my implementation.</span></p><p class="c0 c2"><span class="c3"></span></p><p class="c0"><span class="c3">Setup: index.php page to log into, vhash program that acts like sha1sum etc</span></p><p class="c0 c2"><span class="c3"></span></p><p class="c0"><span class="c3">I used hex-rays to decompile the program. &nbsp;See at the bottom for the decompiled output</span></p><p class="c0 c2"><span class="c3"></span></p><p class="c0"><span class="c3">This looks like a pretty standard hash function: &nbsp;It has some init, calls update() on each block of input, and finally calls vhash_final(), which just vhash_update with a fixed block including the length of the code.</span></p><p class="c0 c2"><span class="c3"></span></p><p class="c0"><span class="c3">So we can take our guest/guest cookie, append the block from vhash_update, and then add &amp;user=administrator&amp; to the end.</span></p><p class="c0 c2"><span class="c3"></span></p><p class="c0"><span class="c3">Then start vhash under gdb, break on vhash_init finishing, feed it &ldquo;&amp;user=administrator&amp;&rdquo; on stdin, and restore the state from the guest/guest hash using GDB. &nbsp;Make sure to add in the new length you need, which is the previous cookie plus the extra block from the vhash_final()</span></p><p class="c0 c2"><span class="c3"></span></p><p class="c0"><span class="c3">Here&rsquo;s the python script I used to print out the state I needed to input into gdb, and then the one to send the request:</span></p><p class="c0 c2"><span class="c3"></span></p><p class="c0"><span class="c1">#!/usr/bin/env python</span></p><p class="c0"><span class="c1">import struct</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1"># Pass in the length you&#39;d be passing to vhash_final</span></p><p class="c0"><span class="c1">def compute_trailer(length):</span></p><p class="c0"><span class="c1">&nbsp; # four uint32_t</span></p><p class="c0"><span class="c1">&nbsp; # f[0] = 0x8000_0000</span></p><p class="c0"><span class="c1">&nbsp; # f[1] = length</span></p><p class="c0"><span class="c1">&nbsp; # f[2] = 0</span></p><p class="c0"><span class="c1">&nbsp; # f[3] = 0xFFFF_FFFF</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; finalblock = struct.pack(&#39;&gt;IIII&#39;, 0x80000000, length, 0, 0xFFFFFFFF)</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; bonus = &#39;&amp;username=administrator&amp;&#39;</span></p><p class="c0"><span class="c1">&nbsp; open(&#39;append-data&#39;, &#39;w&#39;).write(finalblock + bonus)</span></p><p class="c0"><span class="c1">&nbsp; open(&#39;bonus&#39;, &#39;w&#39;).write(bonus)</span></p><p class="c0"><span class="c1">&nbsp; print &quot;wrote trailer to append-data&quot;</span></p><p class="c0"><span class="c1">&nbsp; return finalblock + bonus</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">def gdb_restore_state(hmac):</span></p><p class="c0"><span class="c1">&nbsp; state = []</span></p><p class="c0"><span class="c1">&nbsp; for _ in xrange(8):</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; for m in struct.unpack(&#39;&gt;IIII&#39;, hmac[0:4*4]):</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; state.append(m)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; hmac = hmac[4*4:]</span></p><p class="c0"><span class="c1">&nbsp; assert(len(hmac) == 0)</span></p><p class="c0"><span class="c1">&nbsp; for i, data in enumerate(state):</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; print &quot;set vctx-&gt;state[&quot;, i, &quot;] = &quot;, data</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1"># take the content part of the cookie</span></p><p class="c0"><span class="c1">def parse_up_cookie(cookie):</span></p><p class="c0"><span class="c1">&nbsp; auth, data = cookie.split(&quot;|&quot;)</span></p><p class="c0"><span class="c1">&nbsp; hmac = auth.split(&quot;=&quot;)[1].decode(&#39;hex&#39;)</span></p><p class="c0"><span class="c1">&nbsp; gdb_restore_state(hmac)</span></p><p class="c0"><span class="c1">&nbsp; return data</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">print &quot;break vhash_init&quot;</span></p><p class="c0"><span class="c1">print &quot;run &lt; bonus&quot;</span></p><p class="c0"><span class="c1">print &quot;finish&quot; # Get back to main</span></p><p class="c0"><span class="c1">print &quot;step&quot; # set size = 0</span></p><p class="c0"><span class="c1">data = parse_up_cookie(open(&quot;real-cookie&quot;).read().strip())</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">print &quot;set size = &quot;, len(data)</span></p><p class="c0"><span class="c1">print &quot;p vctx&quot;</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">print data</span></p><p class="c0"><span class="c1">print &quot;The data is length &quot;, len(data)</span></p><p class="c0"><span class="c1">append = compute_trailer(len(data))</span></p><p class="c0"><span class="c1">open(&#39;real-data&#39;, &#39;w&#39;).write(data)</span></p><p class="c0"><span class="c1">print &quot;Wrote data to real-data&quot;</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">#!/usr/bin/env python</span></p><p class="c0"><span class="c1">import urllib</span></p><p class="c0"><span class="c1">import urllib2</span></p><p class="c0"><span class="c1">opener = urllib2.build_opener()</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1"># paste this value from the GDB output</span></p><p class="c0"><span class="c1">auth = &#39;d80d05ec2d4e4f3a3e93358ff4c1534cb9e5bd45a274d42f70fc465867af6ae2615f00e5855ea9330593161ff116f7fd6ac5a6d2d6dfe682639999337c9229ae53203b1a74b53b844a3319ffa65ddf3144f2709e2a37085a2e6ee684344922d5069eaef0f58cf1e1b9795f5a6d84e5f8b3952812ff390fedd9f2b30d8c5c8cbc&#39;</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">trailer = open(&#39;append-data&#39;).read().strip()</span></p><p class="c0"><span class="c1">real = open(&#39;real-data&#39;).read().strip()</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">cookie = &quot;auth=&quot; + auth + &quot;|&quot; + urllib.quote_plus(real + trailer)</span></p><p class="c0"><span class="c1">print cookie</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">opener.addheaders.append((&#39;Cookie&#39;, cookie))</span></p><p class="c0"><span class="c1">try:</span></p><p class="c0"><span class="c1">&nbsp;f = opener.open(&quot;http://thenewandlessbrokenvhash.ctf.bsidessf.net:9292/index.php&quot;)</span></p><p class="c0"><span class="c1">&nbsp;print f.read()</span></p><p class="c0"><span class="c1">except Exception as e:</span></p><p class="c0"><span class="c1">&nbsp;print e</span></p><p class="c0"><span class="c1">&nbsp;print e.read()</span></p><p class="c0 c2"><span class="c3"></span></p><p class="c0 c2"><span class="c3"></span></p><p class="c0 c2"><span class="c3"></span></p><p class="c0 c2"><span class="c3"></span></p><p class="c0 c2"><span class="c3"></span></p><p class="c0 c2"><span class="c3"></span></p><p class="c0"><span class="c3">Decompiler output:</span></p><p class="c0"><span class="c1">void __fastcall vhash_init(vhash_ctx *vctx)</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span class="c1">&nbsp; memcpy(vctx, &quot;vhas&quot;, 4uLL);</span></p><p class="c0"><span class="c1">&nbsp; memcpy(&amp;vctx-&gt;state[1], &quot;h: r&quot;, 4uLL);</span></p><p class="c0"><span class="c1">&nbsp; memcpy(&amp;vctx-&gt;state[2], &quot;ock &quot;, 4uLL);</span></p><p class="c0"><span class="c1">&nbsp; memcpy(&amp;vctx-&gt;state[3], &quot;hard&quot;, 4uLL);</span></p><p class="c0"><span class="c1">&nbsp; memcpy(&amp;vctx-&gt;state[4], &quot; 102&quot;, 4uLL);</span></p><p class="c0"><span class="c1">&nbsp; memcpy(&amp;vctx-&gt;state[5], &quot;4 bi&quot;, 4uLL);</span></p><p class="c0"><span class="c1">&nbsp; memcpy(&amp;vctx-&gt;state[6], &quot;t se&quot;, 4uLL);</span></p><p class="c0"><span class="c1">&nbsp; memcpy(&amp;vctx-&gt;state[7], &quot;curi&quot;, 4uLL);</span></p><p class="c0"><span class="c1">&nbsp; memcpy(&amp;vctx-&gt;state[8], &quot;ty. &quot;, 4uLL);</span></p><p class="c0"><span class="c1">&nbsp; memcpy(&amp;vctx-&gt;state[9], &quot;For &quot;, 4uLL);</span></p><p class="c0"><span class="c1">&nbsp; memcpy(&amp;vctx-&gt;state[10], &quot;thos&quot;, 4uLL);</span></p><p class="c0"><span class="c1">&nbsp; memcpy(&amp;vctx-&gt;state[11], &quot;e sp&quot;, 4uLL);</span></p><p class="c0"><span class="c1">&nbsp; memcpy(&amp;vctx-&gt;state[12], &quot;ecia&quot;, 4uLL);</span></p><p class="c0"><span class="c1">&nbsp; memcpy(&amp;vctx-&gt;state[13], &quot;l mo&quot;, 4uLL);</span></p><p class="c0"><span class="c1">&nbsp; memcpy(&amp;vctx-&gt;state[14], &quot;mome&quot;, 4uLL);</span></p><p class="c0"><span class="c1">&nbsp; memcpy(&amp;vctx-&gt;state[15], &quot;nts &quot;, 4uLL);</span></p><p class="c0"><span class="c1">&nbsp; memcpy(&amp;vctx-&gt;state[16], &quot;when&quot;, 4uLL);</span></p><p class="c0"><span class="c1">&nbsp; memcpy(&amp;vctx-&gt;state[17], &quot; you&quot;, 4uLL);</span></p><p class="c0"><span class="c1">&nbsp; memcpy(&amp;vctx-&gt;state[18], &quot; nee&quot;, 4uLL);</span></p><p class="c0"><span class="c1">&nbsp; memcpy(&amp;vctx-&gt;state[19], &quot;d th&quot;, 4uLL);</span></p><p class="c0"><span class="c1">&nbsp; memcpy(&amp;vctx-&gt;state[20], &quot;robb&quot;, 4uLL);</span></p><p class="c0"><span class="c1">&nbsp; memcpy(&amp;vctx-&gt;state[21], &quot;ing &quot;, 4uLL);</span></p><p class="c0"><span class="c1">&nbsp; memcpy(&amp;vctx-&gt;state[22], &quot;perf&quot;, 4uLL);</span></p><p class="c0"><span class="c1">&nbsp; memcpy(&amp;vctx-&gt;state[23], &quot;orma&quot;, 4uLL);</span></p><p class="c0"><span class="c1">&nbsp; memcpy(&amp;vctx-&gt;state[24], &quot;nce.&quot;, 4uLL);</span></p><p class="c0"><span class="c1">&nbsp; memcpy(&amp;vctx-&gt;state[25], &quot; Ask&quot;, 4uLL);</span></p><p class="c0"><span class="c1">&nbsp; memcpy(&amp;vctx-&gt;state[26], &quot; you&quot;, 4uLL);</span></p><p class="c0"><span class="c1">&nbsp; memcpy(&amp;vctx-&gt;state[27], &quot;r do&quot;, 4uLL);</span></p><p class="c0"><span class="c1">&nbsp; memcpy(&amp;vctx-&gt;state[28], &quot;ctor&quot;, 4uLL);</span></p><p class="c0"><span class="c1">&nbsp; memcpy(&amp;vctx-&gt;state[29], &quot; abo&quot;, 4uLL);</span></p><p class="c0"><span class="c1">&nbsp; memcpy(&amp;vctx-&gt;state[30], &quot;ut v&quot;, 4uLL);</span></p><p class="c0"><span class="c1">&nbsp; memcpy(&amp;vctx-&gt;state[31], &quot;hash&quot;, 4uLL);</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">void __fastcall vhash_round(vhash_ctx *vctx)</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span class="c1">&nbsp; uint32_t v1; // edx@5</span></p><p class="c0"><span class="c1">&nbsp; int i; // [sp+10h] [bp-8h]@1</span></p><p class="c0"><span class="c1">&nbsp; int ia; // [sp+10h] [bp-8h]@4</span></p><p class="c0"><span class="c1">&nbsp; int ib; // [sp+10h] [bp-8h]@7</span></p><p class="c0"><span class="c1">&nbsp; int ic; // [sp+10h] [bp-8h]@10</span></p><p class="c0"><span class="c1">&nbsp; int id; // [sp+10h] [bp-8h]@13</span></p><p class="c0"><span class="c1">&nbsp; uint32_t t; // [sp+14h] [bp-4h]@13</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; for ( i = 0; i &lt;= 31; ++i )</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; ++vctx-&gt;state[i];</span></p><p class="c0"><span class="c1">&nbsp; for ( ia = 0; ia &lt;= 31; ++ia )</span></p><p class="c0"><span class="c1">&nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; v1 = __ROL4__(vctx-&gt;state[ia], ia);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; vctx-&gt;state[ia] = v1;</span></p><p class="c0"><span class="c1">&nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; for ( ib = 0; ib &lt;= 31; ++ib )</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; vctx-&gt;state[ib] += vctx-&gt;state[((((unsigned int)((ib + 1) &gt;&gt; 31) &gt;&gt; 27) + (_BYTE)ib + 1) &amp; 0x1F)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;- ((unsigned int)((ib + 1) &gt;&gt; 31) &gt;&gt; 27)];</span></p><p class="c0"><span class="c1">&nbsp; for ( ic = 0; ic &lt;= 31; ++ic )</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; vctx-&gt;state[ic] ^= vctx-&gt;state[((((unsigned int)((ic + 7) &gt;&gt; 31) &gt;&gt; 27) + (_BYTE)ic + 7) &amp; 0x1F)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;- ((unsigned int)((ic + 7) &gt;&gt; 31) &gt;&gt; 27)];</span></p><p class="c0"><span class="c1">&nbsp; t = vctx-&gt;state[0];</span></p><p class="c0"><span class="c1">&nbsp; for ( id = 0; id &lt;= 30; ++id )</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; vctx-&gt;state[id] = vctx-&gt;state[id + 1];</span></p><p class="c0"><span class="c1">&nbsp; vctx-&gt;state[31] = t;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">void __fastcall vhash_update(vhash_ctx *vctx, uint32_t (*in)[4])</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span class="c1">&nbsp; int i; // [sp+1Ch] [bp-4h]@1</span></p><p class="c0"><span class="c1">&nbsp; int ia; // [sp+1Ch] [bp-4h]@4</span></p><p class="c0"><span class="c1">&nbsp; int ib; // [sp+1Ch] [bp-4h]@7</span></p><p class="c0"><span class="c1">&nbsp; int ic; // [sp+1Ch] [bp-4h]@10</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; for ( i = 0; i &lt;= 31; ++i )</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; vctx-&gt;state[i] += (*in)[((((unsigned int)((unsigned __int64)i &gt;&gt; 32) &gt;&gt; 30) + (_BYTE)i) &amp; 3)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - ((unsigned int)((unsigned __int64)i &gt;&gt; 32) &gt;&gt; 30)];</span></p><p class="c0"><span class="c1">&nbsp; for ( ia = 0; ia &lt;= 511; ++ia )</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; vhash_round(vctx);</span></p><p class="c0"><span class="c1">&nbsp; for ( ib = 0; ib &lt;= 31; ++ib )</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; vctx-&gt;state[ib] ^= (*in)[((((unsigned int)((unsigned __int64)ib &gt;&gt; 32) &gt;&gt; 30) + (_BYTE)ib) &amp; 3)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;- ((unsigned int)((unsigned __int64)ib &gt;&gt; 32) &gt;&gt; 30)];</span></p><p class="c0"><span class="c1">&nbsp; for ( ic = 0; ic &lt;= 511; ++ic )</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; vhash_round(vctx);</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">void __fastcall vhash_final(vhash_ctx *vctx, uint32_t len)</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span class="c1">&nbsp; __int64 v2; // rax@1</span></p><p class="c0"><span class="c1">&nbsp; uint32_t f[4]; // [sp+10h] [bp-20h]@1</span></p><p class="c0"><span class="c1">&nbsp; __int64 v4; // [sp+28h] [bp-8h]@1</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; v4 = *MK_FP(__FS__, 40LL);</span></p><p class="c0"><span class="c1">&nbsp; f[0] = 0x80000000;</span></p><p class="c0"><span class="c1">&nbsp; f[1] = len;</span></p><p class="c0"><span class="c1">&nbsp; f[2] = 0;</span></p><p class="c0"><span class="c1">&nbsp; f[3] = 0xFFFFFFFF;</span></p><p class="c0"><span class="c1">&nbsp; vhash_update(vctx, (uint32_t (*)[4])f);</span></p><p class="c0"><span class="c1">&nbsp; v2 = *MK_FP(__FS__, 40LL) ^ v4;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">void __fastcall print_block(uint32_t (*block)[4])</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span class="c1">&nbsp; fprintf(stderr, &quot;Block: %08x %08x %08x %08x\n&quot;, (*block)[0], (*block)[1], (*block)[2], (*block)[3]);</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">void __fastcall print_state(vhash_ctx *vctx)</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span class="c1">&nbsp; int i; // [sp+1Ch] [bp-4h]@1</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; fwrite(&quot;State:\n&quot;, 1uLL, 7uLL, stderr);</span></p><p class="c0"><span class="c1">&nbsp; for ( i = 0; i &lt;= 7; ++i )</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; fprintf(</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; stderr,</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &quot;%08x %08x %08x %08x\n&quot;,</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; vctx-&gt;state[4 * i],</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; vctx-&gt;state[4 * i + 1],</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; vctx-&gt;state[4 * i + 2],</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; vctx-&gt;state[4 * i + 3]);</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">void __fastcall print_hash(vhash_ctx *vctx)</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span class="c1">&nbsp; int i; // [sp+1Ch] [bp-4h]@1</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; for ( i = 0; i &lt;= 7; ++i )</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; printf(</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &quot;%08x%08x%08x%08x&quot;,</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; vctx-&gt;state[4 * i],</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; vctx-&gt;state[4 * i + 1],</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; vctx-&gt;state[4 * i + 2],</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; vctx-&gt;state[4 * i + 3]);</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">int __cdecl main(int argc, const char **argv, const char **envp)</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span class="c1">&nbsp; int result; // eax@11</span></p><p class="c0"><span class="c1">&nbsp; __int64 v4; // rcx@11</span></p><p class="c0"><span class="c1">&nbsp; uint8_t inbyte; // [sp+Bh] [bp-B5h]@3</span></p><p class="c0"><span class="c1">&nbsp; int i; // [sp+Ch] [bp-B4h]@2</span></p><p class="c0"><span class="c1">&nbsp; uint32_t size; // [sp+10h] [bp-B0h]@1</span></p><p class="c0"><span class="c1">&nbsp; int done; // [sp+14h] [bp-ACh]@1</span></p><p class="c0"><span class="c1">&nbsp; ssize_t ret; // [sp+18h] [bp-A8h]@3</span></p><p class="c0"><span class="c1">&nbsp; uint32_t block[4]; // [sp+20h] [bp-A0h]@2</span></p><p class="c0"><span class="c1">&nbsp; vhash_ctx vctx; // [sp+30h] [bp-90h]@1</span></p><p class="c0"><span class="c1">&nbsp; __int64 v12; // [sp+B8h] [bp-8h]@1</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; v12 = *MK_FP(__FS__, 40LL);</span></p><p class="c0"><span class="c1">&nbsp; done = 0;</span></p><p class="c0"><span class="c1">&nbsp; vhash_init(&amp;vctx);</span></p><p class="c0"><span class="c1">&nbsp; size = 0;</span></p><p class="c0"><span class="c1">&nbsp; while ( !done )</span></p><p class="c0"><span class="c1">&nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; memset(block, 0, 0x10uLL);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; for ( i = 0; (unsigned int)i &lt;= 15; ++i )</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; ret = read(0, &amp;inbyte, 1uLL);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; if ( ret == 1 )</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; ++size;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; block[i / 4] |= inbyte &lt;&lt; 8 * (3 - (char)i % 4);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; else if ( ret &lt;= 0 )</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; done = 1;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; break;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; vhash_update(&amp;vctx, (uint32_t (*)[4])block);</span></p><p class="c0"><span class="c1">&nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; vhash_final(&amp;vctx, size);</span></p><p class="c0"><span class="c1">&nbsp; print_hash(&amp;vctx);</span></p><p class="c0"><span class="c1">&nbsp; puts(&quot; -&quot;);</span></p><p class="c0"><span class="c1">&nbsp; result = 0;</span></p><p class="c0"><span class="c1">&nbsp; v4 = *MK_FP(__FS__, 40LL) ^ v12;</span></p><p class="c0"><span class="c1">&nbsp; return result;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0 c2"><span class="c3"></span></p></body></html>